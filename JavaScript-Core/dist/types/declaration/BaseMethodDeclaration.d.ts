import BaseDeclaration from './BaseDeclaration';
import IMethodDeclaration from "./IMethodDeclaration";
import { ArgumentList, Argument, Identifier } from '../grammar';
import { IParameter, ParameterList } from '../param';
import { Specificity } from "../grammar";
import { IType } from "../type";
import { CategoryDeclaration, IDeclaration } from "./index";
import { Dialect } from "../parser";
import { Context, Transpiler } from "../runtime";
import { IValue } from "../value";
import { IMethodInfo } from "../runtime/Catalog";
import { DeclarationStatement } from "../statement";
export default abstract class BaseMethodDeclaration extends BaseDeclaration implements IMethodDeclaration {
    parameters: ParameterList;
    returnType: IType | null;
    memberOf: CategoryDeclaration<any> | null;
    closureOf: IDeclaration | null;
    declarationOf: DeclarationStatement<IMethodDeclaration> | null;
    constructor(id: Identifier, parameters: ParameterList | null, returnType: IType | null);
    toDeclarationInfo(context: Context): IMethodInfo;
    getType(context: Context): IType;
    isAbstract(): boolean;
    isReference: () => boolean;
    asReference(): BaseMethodDeclaration;
    isEligibleAsMain(): boolean;
    getDeclarationType(): string;
    getSignature(dialect: Dialect): string;
    getProto(context: Context): string;
    getTranspiledName(context: Context, methodName?: string): string;
    fullDeclare(transpiler: Transpiler, id: Identifier): void;
    transpileProlog(transpiler: Transpiler): void;
    transpileEpilog(transpiler: Transpiler): void;
    transpileMethodType(transpiler: Transpiler): void;
    unregister(context: Context): void;
    register(context: Context): void;
    registerParameters(context: Context): void;
    abstract check(context: Context, isStart?: boolean): IType;
    abstract checkChild(context: Context): IType;
    abstract interpret(context: Context): IValue | null;
    declareCall(transpiler: Transpiler): void;
    transpileCall(transpiler: Transpiler, args: ArgumentList | null, refOnly: boolean): void;
    declareParameters(transpiler: Transpiler): void;
    isAssignableTo(context: Context, args: ArgumentList, checkInstance: boolean, allowDerived: boolean): boolean;
    isArgumentAssignableTo(context: Context, parameter: IParameter, argument: Argument, checkInstance: boolean, allowDerived: boolean): boolean;
    computeSpecificity(context: Context, parameter: IParameter, argument: Argument, checkInstance: boolean, allowDerived: boolean): Specificity;
    isAssignableFrom(context: Context, args: ArgumentList): boolean;
    static isArgumentAssignableFrom(context: Context, parameter: IParameter, argument: Argument): boolean;
}
