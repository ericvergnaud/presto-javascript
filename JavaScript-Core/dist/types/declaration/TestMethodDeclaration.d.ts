import BaseDeclaration from './BaseDeclaration';
import { IType } from '../type';
import { ExecutionError } from '../error';
import { Argument, ArgumentList, Identifier, Specificity } from '../grammar';
import { DeclarationStatement, IStatement, StatementList } from '../statement';
import { AssertionList, SymbolExpression } from '../expression';
import { Context, Transpiler } from "../runtime";
import { ITestInfo } from "../runtime/Catalog";
import { Dialect, Section } from "../parser";
import { CodeWriter } from "../utils";
import { IValue } from "../value";
import { CategoryDeclaration, IDeclaration, IMethodDeclaration } from "./index";
import { IParameter, ParameterList } from "../param";
export default class TestMethodDeclaration extends BaseDeclaration implements IMethodDeclaration {
    statements: StatementList;
    assertions: AssertionList;
    error: SymbolExpression | null;
    closureOf: IDeclaration | null;
    memberOf: CategoryDeclaration<any> | null;
    declarationOf: DeclarationStatement<IMethodDeclaration> | null;
    parameters: ParameterList | null;
    returnType: IType | null;
    constructor(id: Identifier, stmts: StatementList, assertions: AssertionList, error: SymbolExpression | null);
    locateSectionAtLine(line: number): Section | null;
    getDeclarationType(): string;
    cleanId(): string;
    declare(transpiler: Transpiler): void;
    transpile(transpiler: Transpiler): void;
    transpileAssertions(transpiler: Transpiler): void;
    transpileExpectedError(transpiler: Transpiler): void;
    check(context: Context): IType;
    checkStatement(context: Context, statement: IStatement): void;
    register(context: Context): void;
    unregister(context: Context): void;
    getType(context: Context): IType;
    interpret(context: Context): IValue | null;
    interpretNoError(context: Context): void;
    interpretAsserts(context: Context): void;
    static print(msg: string): void;
    printMissingError(context: Context, expected: string, actual: string): void;
    printFailedAssertion(context: Context, expected: string, actual: string): void;
    printSuccess(context: Context): void;
    interpretBody(context: Context): boolean;
    interpretError(context: Context, error: Error): void;
    interpretPromptoError(context: Context, error: ExecutionError): void;
    private getErrorName;
    toDialect(writer: CodeWriter): void;
    toMDialect(writer: CodeWriter): void;
    toEDialect(writer: CodeWriter): void;
    toODialect(writer: CodeWriter): void;
    toDeclarationInfo(context: Context): ITestInfo;
    checkChild(context: Context): IType;
    getProto(context?: Context): string;
    getTranspiledName(context: Context): string;
    isAbstract(): boolean;
    registerParameters(context: Context): void;
    transpileMethodType(transpiler: Transpiler): void;
    isReference(): boolean;
    asReference(): IMethodDeclaration;
    isAssignableTo(context: Context, args: ArgumentList, checkInstance: boolean, allowDerived: boolean): boolean;
    isAssignableFrom(context: Context, args: ArgumentList): boolean;
    getSignature(dialect?: Dialect): string;
    computeSpecificity(context: Context, param: IParameter | null, argument: Argument, checkInstance: boolean, allowDerived: boolean): Specificity;
    declareCall(transpiler: Transpiler): void;
    transpileCall(transpiler: Transpiler, args: ArgumentList | null, refOnly?: boolean): void;
    fullDeclare(transpiler: Transpiler, id: Identifier): void;
}
