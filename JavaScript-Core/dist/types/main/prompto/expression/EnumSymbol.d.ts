import BaseExpression from './BaseExpression';
import { Identifier } from "../grammar";
import { Context } from "../runtime";
import { IStorable } from "../store";
import INamed from "../grammar/INamed";
import IValue from "../value/IValue";
import { JsonParent, JsonNode } from '../json';
import { CodeWriter } from "../utils";
import { IResource } from '../value';
import IEnumeratedType from "../type/IEnumeratedType";
import IValueIterable from "../value/IValueIterable";
export default abstract class EnumSymbol<T extends IEnumeratedType> extends BaseExpression implements INamed, IValue {
    id: Identifier;
    type: T;
    mutable: boolean;
    constructor(id: Identifier);
    value: any;
    get name(): string;
    getType(context: Context): T;
    register(context: Context): void;
    unregister(context: Context): void;
    getStorableData(): any;
    collectStorables(storables: Set<IStorable>): void;
    equals(value: any): boolean;
    toDocumentValue(context: Context): IValue;
    toJsonStream(context: Context, values: JsonParent, instanceId: null, fieldName: string, withType: boolean, binaries: Map<string, never> | null): void;
    toJsonNode(): JsonNode;
    convertToJavaScript(): string;
    toEDialect(writer: CodeWriter): void;
    toMDialect(writer: CodeWriter): void;
    toODialect(writer: CodeWriter): void;
    abstract toDialect(writer: CodeWriter): void;
    CompareTo(context: Context, other: IValue): number;
    GetMemberValue(context: Context, member: Identifier, autoCreate?: boolean | undefined): IValue;
    GetItemValue(context: Context, item: IValue, autoCreate?: boolean | undefined): IValue;
    Multiply(context: Context, other: IValue): IValue;
    Divide(context: Context, other: IValue): IValue;
    IntDivide(context: Context, other: IValue): IValue;
    Modulo(context: Context, other: IValue): IValue;
    Minus(context: Context): IValue;
    isIterable(): boolean;
    SetMemberValue(context: Context, member: Identifier, value: IValue): void;
    SetItemValue(context: Context, item: IValue, value: IValue): void;
    Add(context: Context, other: IValue): IValue;
    Subtract(context: Context, other: IValue): IValue;
    And(context: Context, other: IValue): IValue;
    Or(context: Context, other: IValue): IValue;
    Not(context: Context): IValue;
    isResource(): boolean;
    asResource(): IResource;
    asIterable(context: Context): IValueIterable;
    isSliceable(): boolean;
}
