import ContainerType from './ContainerType';
import { Identifier } from '../grammar';
import { IValue, SetValue } from '../value';
import IType from "./IType";
import { Context, Transpiler } from "../runtime";
import { Section } from "../parser";
import { IExpression } from "../expression";
import { IMethodDeclaration } from "../declaration";
export default class ListType extends ContainerType {
    _mutable: boolean;
    constructor(itemType: IType, mutable?: boolean);
    withItemType(itemType: IType): IType;
    asMutable(context: Context, mutable: boolean): IType;
    declare(transpiler: Transpiler): void;
    transpile(transpiler: Transpiler): void;
    getTranspiledName(context: Context): string;
    convertJavaScriptValueToPromptoValue(context: Context, value: any, returnType: IType | null): IValue;
    isAssignableFrom(context: Context, other: IType): boolean;
    equals(other: any): boolean;
    checkAdd(context: Context, section: Section, other: IType, tryReverse: boolean): IType;
    declareAdd(transpiler: Transpiler, other: IType, tryReverse: boolean, left: IExpression, right: IExpression): void;
    transpileAdd(transpiler: Transpiler, other: IType, tryReverse: boolean, left: IExpression, right: IExpression): void;
    checkSubtract(context: Context, section: Section, other: IType): IType;
    declareSubtract(transpiler: Transpiler, other: IType, left: IExpression, right: IExpression): void;
    transpileSubtract(transpiler: Transpiler, other: IType, left: IExpression, right: IExpression): void;
    checkItem(context: Context, section: Section, itemType: IType): IType;
    declareItem(transpiler: Transpiler, itemType: IType, item: IExpression): void;
    transpileItem(transpiler: Transpiler, itemType: IType, item: IExpression): void;
    transpileAssignItemValue(transpiler: Transpiler, item: IExpression, expression: IExpression): void;
    checkMultiply(context: Context, section: Section, other: IType, tryReverse: boolean): IType;
    declareMultiply(transpiler: Transpiler, other: IType, tryReverse: boolean, left: IExpression, right: IExpression): void;
    transpileMultiply(transpiler: Transpiler, other: IType, tryReverse: boolean, left: IExpression, right: IExpression): void;
    checkSlice(context: Context, section: Section): IType;
    declareSlice(transpiler: Transpiler, first: IExpression, last: IExpression): void;
    transpileSlice(transpiler: Transpiler, first: IExpression, last: IExpression): void;
    declareContains(transpiler: Transpiler, other: IType, container: IExpression, item: IExpression): void;
    transpileContains(transpiler: Transpiler, other: IType, container: IExpression, item: IExpression): void;
    checkHasAllOrAny(context: Context, section: Section, other: IType): IType;
    declareHasAllOrAny(transpiler: Transpiler, other: IType, container: IExpression, items: IExpression): void;
    transpileHasAllValue(transpiler: Transpiler, other: IType, container: IExpression, items: IExpression): void;
    transpileHasAnyValue(transpiler: Transpiler, other: IType, container: IExpression, items: IExpression): void;
    transpileHasAllPredicate(transpiler: Transpiler, other: IType, container: IExpression, predicate: IExpression): void;
    transpileHasAnyPredicate(transpiler: Transpiler, other: IType, container: IExpression, predicate: IExpression): void;
    checkIterator(context: Context, section: Section, source: IExpression): IType;
    getMemberMethods(context: Context, id: Identifier): Set<IMethodDeclaration>;
    containerToSet(value: IValue): SetValue;
}
