import NativeType from './NativeType';
import { IExpression } from '../expression';
import { Identifier } from '../grammar';
import { Context, Transpiler } from '../runtime';
import { DocumentValue, NullValue, IntegerValue, DecimalValue, TextValue, IValue, BooleanValue } from '../value';
import { TextLiteral } from '../literal';
import IType from "./IType";
import { Section } from "../parser";
import { JsonNode } from "../json";
import { IMethodDeclaration } from "../declaration";
export default class DocumentType extends NativeType {
    static instance: DocumentType;
    constructor();
    withItemType(itemType: IType): IType;
    isAssignableFrom(context: Context, other: IType): boolean;
    isMoreSpecificThan(context: Context, other: IType): boolean;
    checkMember(context: Context, section: Section, id: Identifier): IType;
    checkAdd(context: Context, section: Section, other: IType, tryReverse: boolean): IType;
    declareAdd(transpiler: Transpiler, other: IType, tryReverse: boolean, left: IExpression, right: IExpression): void;
    transpileAdd(transpiler: Transpiler, other: IType, tryReverse: boolean, left: IExpression, right: IExpression): void;
    convertJavaScriptValueToPromptoValue(context: Context, value: any, returnType: IType | null): IValue;
    declare(transpiler: Transpiler): void;
    transpile(transpiler: Transpiler): void;
    declareMember(transpiler: Transpiler, member: Identifier): void;
    transpileMember(transpiler: Transpiler, member: Identifier): void;
    transpileAssignMember(transpiler: Transpiler, member: Identifier): void;
    transpileAssignMemberValue(transpiler: Transpiler, member: Identifier, expression: IExpression): void;
    checkItem(context: Context, section: Section, itemType: IType): IType;
    declareItem(transpiler: Transpiler, type: IType, item: IExpression): void;
    transpileItem(transpiler: Transpiler, type: IType, item: IExpression): void;
    transpileAssignItemValue(transpiler: Transpiler, item: IExpression, expression: IExpression): void;
    declareSorted(transpiler: Transpiler, key: IExpression | null): void;
    transpileSortedComparator(transpiler: Transpiler, key: IExpression | null, desc: boolean): void;
    transpileGlobalMethodSortedComparator(transpiler: Transpiler, name: string, desc: boolean): void;
    transpileEntrySortedComparator(transpiler: Transpiler, key: IExpression, descending: boolean): void;
    transpileEqualEntries(transpiler: Transpiler, key: IExpression): void;
    transpileGreaterEntries(transpiler: Transpiler, key: IExpression): void;
    transpileExpressionSortedComparator(transpiler: Transpiler, key: IExpression, descending: boolean): void;
    readJSONValue(context: Context, node: JsonNode, parts: Map<string, ArrayBuffer>): DocumentValue;
    readJSONField(context: Context, node: JsonNode, parts: Map<string, ArrayBuffer>): TextValue | BooleanValue | NullValue | DecimalValue | IntegerValue;
    getSortedComparator(context: Context, desc: boolean, key: IExpression | Identifier | null): (o1: IValue, o2: IValue) => number;
    findGlobalMethod(context: Context, id: Identifier): IMethodDeclaration | null;
    getGlobalMethodSortedComparator(context: Context, desc: boolean, decl: IMethodDeclaration): (o1: IValue, o2: IValue) => number;
    getEntrySortedComparator(context: Context, desc: boolean, key: TextLiteral): (o1: IValue, o2: IValue) => number;
    getExpressionSortedComparator(context: Context, desc: boolean, expression: IExpression): (o1: IValue, o2: IValue) => number;
}
