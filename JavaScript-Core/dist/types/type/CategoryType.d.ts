import BaseType from './BaseType';
import { CategoryDeclaration, IDeclaration, IMethodDeclaration } from '../declaration';
import { IExpression, CategorySymbol } from '../expression';
import { Operator, Identifier } from '../grammar';
import { Context, Score, Transpiler } from '../runtime';
import { MethodCall } from '../statement';
import { IStored, TypeFamily } from '../store';
import { CodeWriter } from '../utils';
import { Section } from '../parser';
import { ConcreteInstance, Instance, IValue } from "../value";
import IType from "./IType";
export default class CategoryType extends BaseType {
    _mutable: boolean;
    constructor(id: Identifier, mutable?: boolean, family?: TypeFamily);
    get mutable(): boolean;
    asMutable(context: Context, mutable: boolean): CategoryType;
    isStorable(context: Context): boolean;
    anyfy(): IType;
    resolve(context: Context, onError?: (type: IType) => void): IType;
    toDialect(writer: CodeWriter, skipMutable?: boolean): void;
    getSuperType(context: Context, section: Section): CategoryType | null;
    declare(transpiler: Transpiler): void;
    transpile(transpiler: Transpiler): void;
    transpileInstance(transpiler: Transpiler): void;
    newInstanceFromStored(context: Context, stored: IStored): Instance<unknown>;
    checkUnique(context: Context): void;
    getDeclaration(context: Context): IDeclaration;
    checkMultiply(context: Context, section: Section, other: IType, tryReverse: boolean): IType;
    declareMultiply(transpiler: Transpiler, other: IType, tryReverse: boolean, left: IExpression, right: IExpression): void;
    transpileMultiply(transpiler: Transpiler, other: IType, tryReverse: boolean, left: IExpression, right: IExpression): void;
    checkDivide(context: Context, section: Section, other: IType): IType;
    declareDivide(transpiler: Transpiler, other: IType, left: IExpression, right: IExpression): void;
    transpileDivide(transpiler: Transpiler, other: IType, left: IExpression, right: IExpression): void;
    checkIntDivide(context: Context, section: Section, other: IType): IType;
    declareIntDivide(transpiler: Transpiler, other: IType, left: IExpression, right: IExpression): void;
    transpileIntDivide(transpiler: Transpiler, other: IType, left: IExpression, right: IExpression): void;
    checkModulo(context: Context, section: Section, other: IType): IType;
    declareModulo(transpiler: Transpiler, other: IType, left: IExpression, right: IExpression): void;
    transpileModulo(transpiler: Transpiler, other: IType, left: IExpression, right: IExpression): void;
    checkAdd(context: Context, section: Section, other: IType, tryReverse: boolean): IType;
    declareAdd(transpiler: Transpiler, other: IType, tryReverse: boolean, left: IExpression, right: IExpression): void;
    transpileAdd(transpiler: Transpiler, other: IType, tryReverse: boolean, left: IExpression, right: IExpression): void;
    checkSubtract(context: Context, section: Section, other: IType): IType;
    declareSubtract(transpiler: Transpiler, other: IType, left: IExpression, right: IExpression): void;
    transpileSubtract(transpiler: Transpiler, other: IType, left: IExpression, right: IExpression): void;
    checkOperator(context: Context, other: IType, tryReverse: boolean, operator: Operator): IType | null;
    checkExists(context: Context): void;
    checkMember(context: Context, section: Section, id: Identifier): IType;
    checkAttribute(context: Context, section: Section, id: Identifier): IType;
    checkCategoryAttribute(context: Context, section: Section, decl: CategoryDeclaration<any>, id: Identifier): IType;
    declareMember(transpiler: Transpiler, id: Identifier): void;
    transpileMember(transpiler: Transpiler, id: Identifier): void;
    checkStaticMember(context: Context, section: Section, id: Identifier): IType;
    declareStaticMember(transpiler: Transpiler, id: Identifier): void;
    transpileStaticMember(transpiler: Transpiler, id: Identifier): void;
    getStaticMemberValue(context: Context, id: Identifier): IValue;
    isAssignableFrom(context: Context, other: IType): boolean;
    isAssignableFromCategory(context: Context, other: CategoryType): boolean;
    isDerivedFrom(context: Context, other: CategoryType): boolean;
    isDerivedFromCategory(context: Context, decl: CategoryDeclaration<any>, other: CategoryType): boolean;
    isDerivedFromAnonymous(context: Context, other: IType): boolean;
    isDerivedFromAnonymousCategory(context: Context, thisDecl: CategoryDeclaration<any>, otherDecl: CategoryDeclaration<any>): boolean;
    isAnonymous(): boolean;
    isMoreSpecificThan(context: Context, other: IType): boolean;
    compareSpecifity(context: Context, t1: IType, t2: IType): Score;
    newInstance(context: Context): ConcreteInstance;
    getSortedComparator(context: Context, desc: boolean, key: IExpression): (o1: IValue, o2: IValue) => number;
    getExpressionSortedComparator(context: Context, exp: IExpression, desc: boolean): (o1: IValue, o2: IValue) => number;
    getAttributeSortedComparator(context: Context, id: Identifier, desc: boolean): (o1: IValue, o2: IValue) => number;
    getGlobalMethodSortedComparator(context: Context, decl: IMethodDeclaration, desc: boolean): (o1: IValue, o2: IValue) => number;
    getMemberMethods(context: Context, id: Identifier): Set<IMethodDeclaration>;
    getStaticMemberMethods(context: Context, id: Identifier): Set<IMethodDeclaration>;
    findGlobalMethod(context: Context, id: Identifier): IMethodDeclaration | null;
    makeGlobalCall(context: Context, id: Identifier): MethodCall;
    convertJavaScriptValueToPromptoValue(context: Context, value: any, returnType: IType | null): IValue;
    loadEnumValue(context: Context, name: string): CategorySymbol;
    declareSorted(transpiler: Transpiler, key: IExpression): void;
    getKeyIdentifier(key: IExpression): Identifier;
    transpileSortedComparator(transpiler: Transpiler, key: IExpression, desc: boolean): void;
    transpileExpressionSortedComparator(transpiler: Transpiler, key: IExpression, desc: boolean): void;
    transpileAttributeSortedComparator(transpiler: Transpiler, key: IExpression, desc: boolean): void;
    transpileEqualKeys(transpiler: Transpiler, key: IExpression): void;
    transpileGreaterKeys(transpiler: Transpiler, key: IExpression): void;
    transpileGlobalMethodSortedComparator(transpiler: Transpiler, name: string, desc: boolean): void;
    transpileAssignMemberValue(transpiler: Transpiler, member: Identifier, expression: IExpression): void;
}
