import Store from '../store/Store';
import { MemQueryBuilder, StorableDocument, AuditRecord, AuditMetadata, StoredDocument } from '../memstore';
import { Cursor, Document, List } from '../intrinsic';
import { IStored } from "../store";
import MemQuery from "./MemQuery";
import MemOrderBy from "./MemOrderBy";
import IDbIdFactory from "../store/IDbIdFactory";
declare type Tuple = (any | null)[];
export default class MemStore extends Store {
    nextDbId: number;
    documents: Map<any, StoredDocument>;
    sequences: Map<string, number>;
    nextAuditDbId: number;
    auditRecords: Map<any, AuditRecord>;
    nextAuditMetadataDbId: number;
    auditMetadatas: Map<any, AuditMetadata>;
    constructor();
    nextSequenceValue(name: string): number;
    flush(): void;
    isDbIdType(type: string): boolean;
    deleteAndStore(toDel: any[] | null, toAdd: StorableDocument[] | null, auditMeta: AuditMetadata | null): void;
    deleteAndStoreAsync(toDel: any[] | null, toAdd: StorableDocument[] | null, auditMeta: AuditMetadata | null, andThen: null | (() => void)): void;
    isAuditEnabled(): boolean;
    newAuditMetadata(): AuditMetadata;
    storeAuditMetadata(auditMeta: AuditMetadata | null): AuditMetadata;
    doDelete(dbId: any, auditMeta: AuditMetadata): void;
    doStore(storable: StorableDocument, auditMeta: AuditMetadata): void;
    newAuditRecord(auditMeta: AuditMetadata): AuditRecord;
    fetchUnique(dbId: any): StoredDocument | null;
    fetchOne(query: MemQuery): StoredDocument | null;
    fetchOneAsync(query: MemQuery, andThen: (store: IStored | null) => void): void;
    fetchMany(query: MemQuery): Cursor<StoredDocument>;
    fetchManyAsync(query: MemQuery, andThen: (cursor: Cursor<IStored>) => void): void;
    slice(query: MemQuery, docs: StoredDocument[]): StoredDocument[];
    sort(query: MemQuery, docs: StoredDocument[]): StoredDocument[];
    compareDocuments(doc1: StoredDocument, doc2: StoredDocument, orderBys: MemOrderBy[]): number;
    readTuple(doc: StoredDocument, orderBys: MemOrderBy[]): Tuple;
    readValue(doc: StoredDocument, orderBy: MemOrderBy): any | null;
    compareTuples(tuple1: Tuple, tuple2: Tuple, orderBys: MemOrderBy[]): number;
    fetchMatching(query: MemQuery): StoredDocument[];
    newQueryBuilder(): MemQueryBuilder;
    newStorableDocument(categories: string[], dbIdFactory: IDbIdFactory | null): StorableDocument;
    fetchLatestAuditMetadataId(dbId: any): any | null;
    fetchAllAuditMetadataIds(dbId: any): List<any>;
    fetchAuditMetadata(dbId: any): AuditMetadata | null;
    fetchAuditMetadataAsDocument(dbId: any): Document<string, any> | null;
    fetchLatestAuditRecord(dbId: any): AuditRecord | null;
    fetchLatestAuditRecordAsDocument(dbId: any): Document<string, any> | null;
    fetchAllAuditRecords(dbId: any): List<AuditRecord>;
    fetchAllAuditRecordsAsDocuments(dbId: any): List<Document<string, any>>;
    fetchDbIdsAffectedByAuditMetadataId(dbId: any): List<any>;
    fetchAuditRecordsMatching(auditPredicates: Map<string, any> | null, instancePredicates: Map<string, any> | null): List<AuditRecord>;
    fetchAuditRecordsMatchingAsDocuments(auditPredicates: Map<string, any> | null, instancePredicates: Map<string, any> | null): List<Document<string, any>>;
    deleteAuditRecord(dbId: any): boolean;
    deleteAuditMetadata(dbId: any): boolean;
}
export {};
